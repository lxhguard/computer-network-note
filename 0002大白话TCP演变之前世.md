# 大白话TCP演变之前世

## 演变：完全可靠信道 -> 比特差错 -> 比特差错 丢包 -此前均为停等协议-> 流水线技术

## 传输层提供进程间的逻辑通信，网络层提供主机间的逻辑通信

## 可靠数据传输协议(reliable data transfer protocol) -> rdt

### 完全可靠信道: rdt 1.0

- 假设：分组不会受损，接收方接受数据速率 = 发送方发送数据速率
- 结果：一个发一个收，无需接收方反馈信息给发送方

### 比特差错信道: rdt 2.0 ACK+NAK+无序号 停等协议(stop-and-wait)

- 发送方                    接收方
- 假设：分组中的比特在传输、传播、缓存过程中可能受损，接收方按照发送方顺序依次接收分组
- 解决问题：分组受损
- 解决方案：差错检测(检验和) + 接收方反馈(ACK/NAK) + 重传(重发差错分组)

- 此种协议名称：停等协议(stop-and-wait)
- 协议缺陷：ACK/NAK可能受损，发送方无法知道接收方是否正确接收上一块发送的数据

### 比特差错信道: rdt 2.1 ACK+NAK+有序号

- 解决缺陷方案：1.引入新型分组❌ 2.增长检验和比特✅ 3.重传递当前分组❌ -> 产生冗余分组 -> 造成接收方不知新分组还是重传分组

- 最佳方案：分组新增字段，即序号
- 解决方案：序号 + 差错检测(检验和) + 接收方反馈(ACK/NAK) + 重传(重发差错分组)
- 新问题：ACK，NAK两个字段多余，可仅用ACK一个字段。

### 比特差错信道: rdt 2.3 ACK+有序号

- 思路：如果接收受损分组C，则对其上一个分组B发送ACK，这样发送方接收到同一个分组B的两个ACK(冗余ACK)，发送方重发两次确认分组后的分组，即分组C。

### 比特差错的丢包信道: rdt 3.0  比特交替协议(alternating-bit protocol)

- 关注：如何检测丢包，丢包应该做什么
  
- 解决：发送方负责检测和恢复丢包工作
- 丢包情况：发送方数据分组丢失，接收方对该分组的ACK丢失
- 如何检测丢包？发送方等待足够长的时间，接收不到ACK，便确定丢包
- 新问题：足够长是多久？ 往返时延 + 接收方处理单个分组时间❌ -> 最大时延难以估计，所以可能会等待很长时间
- 新方案：发送方选择一个时间值。在此时间内没收到ACK，则重发该分组  -> 冗余数据分组 rdt 2.1序号解决此问题
- |      设置倒计数定时器：每发送一个分组便启动一个定时器；接收ACK终止定时器。
- PS：最长的分组寿命被假定为大约3分钟[RFC 1323]
- 此种协议名称：比特交替协议(alternating-bit protocol)  分组序号在 0 1 之间交替

#### rdt 1.0 2.0 3.0 本质都是 停等协议，故性能问题：信道利用率极低

- 停等协议：发送一个分组，等待ACK相应
- 解决方案：发送方发送多个分组而无需等待确认 --> 提高利用率  --> 流水线技术
- 带来改变：1.增加序号范围  2.发送方和接收方缓存多个分组  3.前两个取决于如何处理丢失、损坏、延迟的分组，即差错恢复，其有两种方法：GBN,SR。

### 回退N步协议：GBN（又称 滑动窗口协议）

- 序号范围分割4段：已确认，发送未确认(滑动窗口长度为N)，可用未发送，不可用
- PS：TCP序号是按字节流中的字节进行计数的。
- 发送方响应事件类型：1.上层调用 2.收到一个ACK。累积确认。 3.超时事件：分组丢失和时延过长
- 接收方动作：分组正确接收，则发ACK，分组交付上层；反之其他情况，丢弃该分组，并为最近按序接收分组重发ACK
- 性能问题：单个分组的差错就能引起GBN重传大量分组，很多分组没必要重传。流水线可能被大量不必要重传的分组充斥
- 解决方案：发送方仅重传丢失或受损的分组，避免不必要的重传，即SR协议

### 选择重传协议：SR

- 思想：这种个别的、按需的重传要求接收方逐个地确认正确接收的分组。
- SR接收方将确认一个正确接收的分组而不管其是否按序。失序的分组将被缓存直到所有丢失分组皆被收到为止，这时才将一批分组按序交给上层。
- 意味着：发送方和接收方的窗口并不总是一致的。
- 窗口长度 <= 序号空间大小/2
